#!/usr/bin/env ruby
require_relative '../lib/common/common.rb'
require_relative '../lib/indexer/indexer.rb'

# TODO: Den Code übersichtlicher machen.

module Indexer
  class Main
    def initialize
      @logger = Common::Logger.new({labels: {tasks: "Aufgaben", tasks_per_second: "Aufgaben/s"}})
      @logger.add_output($stdout, Common::Logger::INFO)
      @progress = @logger.progress_logger(Common::OrderedHash.new([[:tasks, 0], [:tasks_per_second, nil]]))
      @progress[:tasks_per_second] = proc{|p| p.elapsed_time}
    end
    
    def run
      # In Threads einzelne Dokumente indexieren.
      @logger.log_info "10'000 Dokumente werden indexiert und anschliessend in den Hauptindex eingegliedert."
      @progress.start_display(5.0)
      Common::WorkerThreads.new(10).run do
        while @progress[:tasks] < 10_000 && (doc_id = Indexer::Database.index_queue_fetch)
          Task.load(doc_id).run
          @progress[:tasks] += 1
        end
      end
      @progress.stop_display
      IndexingCache.write_to_disk
    
      # Sortieren der Einträge beginnen...
      @logger.log_info "Sortieren der Zwischenergebnisse gestartet."
      tempfiles = Dir[File.join(Config.paths.index_tmp, "*")]
      @logger.log_info "Anzahl zu sortierender Dateien: #{tempfiles.size}"
      
      @progress.restart_display
      Common::WorkerThreads.new(10).run do
        while (tempfile = tempfiles.pop)
          word = tempfile.split("/")[-1]
          
          # ob bereits eine gesicherte Indexdatei existiert, falls ja wird diese ans Ende des tempfile gehängt
          # und die originale gelöscht...
          destination = Common::Postings.new(word)
          if destination.rows_count > 0
            
          
          
          
          
          destination_path = File.join(Config.paths.postings, word)
          if File.exist? destination_path
            File.open(tempfile, "a") do |file|
              file.write(File.binread(destination_path))
            end
            File.unlink destination_path
          end
      
          # Die temporäre Datei in die Zieldatei hineinsortieren und die temporäre Datei anschliessend löschen.
          destination_file = Common::PostingsFile.new(destination_path, true)
          IndexSorter.sort(Common::PostingsFile.new(tempfile, true), destination_file)
          @progress[:tasks] += 1
          File.unlink tempfile
        
          # PostingsMetadata-File generieren
          Common::PostingsMetadataFile.new(word).generate_for(destination_file)
        end
      end
      @progress.stop_display
    
      @logger.log_info "10'000 Dokumente erfolgreich indexiert und in Hauptindex eingegliedert."
    end
  end
end


if __FILE__ == $0
  Indexer::Main.new.run()
end
