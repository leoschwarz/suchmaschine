#!/usr/bin/env ruby
#require_relative '../lib/database/backend.rb' # TODO: nach lib/common verschieben ? 
require_relative '../lib/common/common.rb'
require_relative '../lib/database/database.rb'
require_relative '../lib/indexer/indexer.rb'

require 'fileutils'

# TODO: Den Code übersichtlicher machen.
Thread.abort_on_exception = true

module Indexer
  class Main
    def initialize
      @logger = Common::Logger.new({labels: {tasks: "Aufgaben", tasks_per_second: "Aufgaben/s"}})
      @logger.add_output($stdout, Common::Logger::INFO)
    end
    
    def run
      @logger.log_info "Indexierer wurde gestartet."
      
      begin
        db = Database::Backend.new
      rescue => e
        @logger.log_exception(e)
        @logger.log_warning("Um den Indexierer ausführen zu können, darf die Datenbank nicht von einem anderen Prozess verwendet werden.")
        Kernel.exit
      end
      
      begin
        # Temporäres Verzeichnis für den Index überprüfen...
        dir = File.join(File.dirname(__FILE__), "..", "tmp", "index")
        if Dir.exist?(dir)
          raise "Bitte das tmp/index-Verzeichniss entleeren."
        else
          Dir.mkdir(dir)
        end
      
        cache = Indexer::IndexingCache.new(dir)
        queue_mutex = Mutex.new
        Common::WorkerThreads.new(20).run(true) do
          loop do
            key = queue_mutex.synchronize do
              db.queue_fetch(:index)
            end
            
            break if key.nil?
            
            raw = db.datastore_get(:metadata, key)
            
            if raw          
              metadata = Common::Database::Metadata.deserialize(raw)
              Task.new(cache, metadata).run unless metadata.nil?
            end
          end
        end
        cache.flush
      
        db.save
        db = nil
      
        # Nun müssen die einzelnen Cache Dateien in tmp/index in eine einzelne finale Cache-Datei sortiert werden.
        @logger.log_info "Die Einträge werden nun gemerged..."
        if File.exist?(Config.paths.index)
          File.unlink Config.paths.index
        end
        FileUtils.touch Config.paths.index
        destination = Common::IndexFile.new(Config.paths.index).writer
        sources = Dir["#{dir}/*"].map{|path| Common::IndexFile.new(path).pointer_reader}
        merger = Indexer::Merger.new(destination, sources)
        merger.merge
      
        @logger.log_info "Merging abgeschlossen, nun wird ein Index der Abschnitte des Index erstellt..."
        destination.metadata.generate
      
        @logger.log_info "Generierung des Indexes ist nun abgeschlossen."
      rescue Exception => e
        db.save unless db.nil?
        raise e
      end
    end
  end
end

if __FILE__ == $0
  Indexer::Main.new.run()
end
